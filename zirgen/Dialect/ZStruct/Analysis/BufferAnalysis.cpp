// Copyright (c) 2024 RISC Zero, Inc.
//
// All rights reserved.

// Analyses what buffers are used by a module.

#include "zirgen/Dialect/ZStruct/Analysis/BufferAnalysis.h"
#include "zirgen/Dialect/ZStruct/IR/TypeUtils.h"
#include "zirgen/Dialect/ZStruct/IR/ZStruct.h"

namespace zirgen::ZStruct {

using namespace mlir;

static const char* tapBufferNameStrs[] = {"accum", "code", "data"};
static const char* globalBufferNameStrs[] = {"global", "mix"};

namespace {

void getRegCount(ModuleOp mod, Attribute layoutAttr, size_t& regCount) {
  layoutAttr.walk([&](ZStruct::RefAttr refAttr) {
    regCount = std::max<size_t>(regCount, refAttr.getIndex() + 1);
  });
  layoutAttr.walk([&](SymbolRefAttr symRef) {
    // Symbolic reference to another layout; follow the reference.
    if (auto target = mod.lookupSymbol<ZStruct::GlobalConstOp>(symRef)) {
      getRegCount(mod, target.getConstant(), regCount);
    }
  });
}

// If this is a top-level layout, return the buffer associated with it.
StringRef getLayoutBuffer(GlobalConstOp globalConstOp) {
  StringRef symName = globalConstOp.getSymName();
  if (!symName.consume_front("layout$"))
    // Not a layout.
    return {};
  if (symName.starts_with("_")) {
    // Not a top-level layout; this is one generated by ExpandLayoutPass.
    return {};
  }
  if (symName.ends_with("$accum"))
    return "accum";
  if (symName == "Top")
    return "data";
  if (symName.starts_with("test$"))
    return "test";
  return symName;
}

} // namespace

BufferAnalysis::BufferAnalysis(mlir::ModuleOp mod) {
  // Buffers that make it into taps
  auto tapBufferNames = llvm::map_to_vector(
      tapBufferNameStrs, [&](auto name) { return StringAttr::get(mod.getContext(), name); });
  for (auto [regGroupId, name] : llvm::enumerate(tapBufferNames)) {
    buffers[name] = BufferDesc{
        .name = name, .kind = Zll::BufferKind::Mutable, .regGroupId = regGroupId, .regCount = 1};
  }

  // Global buffers that are required to exist.
  for (auto name : llvm::map_range(globalBufferNameStrs, [&](auto name) {
         return StringAttr::get(mod.getContext(), name);
       })) {
    buffers[name] =
        BufferDesc{.name = name, .kind = Zll::BufferKind::Global, .global = true, .regCount = 4};
  }

  // Compute how big these buffers need to be.  If we find any other buffers (like "test")
  // we default them to kind BufferKind::Mutable.
  mod.walk([&](ZStruct::GlobalConstOp globalConstOp) {
    StringRef name = getLayoutBuffer(globalConstOp);
    if (name.empty())
      // Not a layout
      return;
    auto layoutAttr = globalConstOp.getConstant();

    BufferDesc& desc = buffers
                           .try_emplace(name,
                                        BufferDesc{.name = StringAttr::get(mod.getContext(), name),
                                                   .kind = Zll::BufferKind::Mutable,
                                                   .regCount = 0})
                           .first->second;

    if (desc.layouts.insert(layoutAttr)) {
      // We haven't seen this layout before; count all the offsets in it to determine size.
      getRegCount(mod, layoutAttr, desc.regCount);
    }
  });

  tapBuffers = llvm::map_to_vector(tapBufferNames, [&](auto name) { return buffers.at(name); });
}

Type BufferDesc::getType(MLIRContext* ctx) const {
  return Zll::BufferType::get(ctx, getValType(ctx), regCount, kind);
}

std::pair<ZStruct::GlobalConstOp, BufferDesc>
BufferAnalysis::getLayoutAndBufferForArgument(mlir::BlockArgument layoutArg) {
  if (!ZStruct::isLayoutType(layoutArg.getType()))
    return {};

  Block* owner = layoutArg.getOwner();
  if (!owner)
    return {};
  Operation* func = owner->getParentOp();
  if (!func)
    return {};
  auto sym = SymbolTable::getSymbolName(func);
  if (!sym)
    return {};
  StringRef componentName = sym.strref();
  componentName.consume_front("check$");
  componentName.consume_front("exec$");
  componentName.consume_back("$accum");

  GlobalConstOp globalConstOp;
  auto mod = func->getParentOfType<ModuleOp>();
  mod.walk([&](GlobalConstOp constOp) {
    if (constOp.getSymName().contains(componentName) && constOp.getType() == layoutArg.getType()) {
      assert(!globalConstOp && "found multiple possible layout symbols for the same buffer");
      globalConstOp = constOp;
    }
  });

  if (!globalConstOp)
    return {};
  StringRef layoutName = getLayoutBuffer(globalConstOp);
  if (layoutName.empty() || !buffers.contains(layoutName))
    return {};
  return {globalConstOp, getBuffer(layoutName)};
}

} // namespace zirgen::ZStruct
