// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
#include "llvm/ADT/DenseSet.h"

#include "zirgen/Dialect/ZHLT/IR/ZHLT.h"
#include "zirgen/Dialect/ZHLT/Transforms/PassDetail.h"

#include <set>
#include <vector>

using namespace mlir;
using namespace zirgen::Zll;
using namespace zirgen::ZStruct;

namespace zirgen::Zhlt {

static std::vector<std::string> tapBufferNames = {"accum", "code", "data"};
static std::vector<std::string> globalBufferNames = {"global", "mix"};

namespace {

template <typename T> bool contains(std::vector<T>& vec, const T& item) {
  return std::find(vec.begin(), vec.end(), item) != vec.end();
}

// If this is a top-level layout, return the buffer associated with it.
StringRef getLayoutBuffer(ZStruct::GlobalConstOp globalConstOp) {
  StringRef symName = globalConstOp.getSymName();
  if (!symName.consume_front("layout$"))
    // Not a layout.
    return {};
  if (symName.starts_with("_")) {
    // Not a top-level layout; this is one generated by ExpandLayoutPass.
    return {};
  }
  if (symName.ends_with("$accum"))
    return "accum";
  if (symName == "Top")
    return "data";
  if (symName.starts_with("test$"))
    return "test";
  return symName;
}

void getRegCount(ModuleOp mod, Attribute layoutAttr, size_t& regCount) {
  layoutAttr.walk([&](ZStruct::RefAttr refAttr) {
    auto refType = llvm::cast<RefType>(refAttr.getType());
    regCount = std::max<size_t>(regCount, refAttr.getIndex() + refType.getElement().getFieldK());
  });
  layoutAttr.walk([&](SymbolRefAttr symRef) {
    // Symbolic reference to another layout; follow the reference.
    if (auto target = mod.lookupSymbol<ZStruct::GlobalConstOp>(symRef)) {
      getRegCount(mod, target.getConstant(), regCount);
    }
  });
}

struct AnalyzeBuffersPass : public AnalyzeBuffersBase<AnalyzeBuffersPass> {
  void runOnOperation() override {
    OpBuilder builder(&getContext());
    SmallVector<BufferDescAttr> bufs;

    llvm::MapVector<StringAttr, size_t> bufSizes;

    // Compute how big these buffers need to be. Besides the special case of
    // "test", we default any other buffers to be mutable tap buffers.
    getOperation()->walk([&](ZStruct::GlobalConstOp globalConstOp) {
      std::string name = getLayoutBuffer(globalConstOp).str();
      if (name.empty())
        // Not a layout
        return;
      // Mark user-defined buffers as tap buffers.
      if (!contains(tapBufferNames, name) && !contains(globalBufferNames, name) && name != "test") {
        tapBufferNames.push_back(name);
      }
      auto layoutAttr = globalConstOp.getConstant();
      getRegCount(getOperation(), layoutAttr, bufSizes[builder.getStringAttr(name)]);
    });

    for (auto [tapGroupId, bufName] : llvm::enumerate(tapBufferNames)) {
      auto bufNameAttr = builder.getStringAttr(bufName);
      bufs.push_back(builder.getAttr<BufferDescAttr>(
          bufNameAttr,
          builder.getType<BufferType>(/*element=*/builder.getType<ValType>(),
                                      /*size=*/std::max<size_t>(bufSizes[bufNameAttr], 1),
                                      /*kind=*/BufferKind::Mutable),
          tapGroupId));
      bufSizes.erase(bufNameAttr);
    }

    for (auto bufName : globalBufferNames) {
      auto bufNameAttr = builder.getStringAttr(bufName);
      bufs.push_back(builder.getAttr<BufferDescAttr>(
          bufNameAttr,
          builder.getType<BufferType>(/*element=*/builder.getType<ValType>(),
                                      /*size=*/std::max<size_t>(bufSizes[bufNameAttr], 4),
                                      /*kind=*/BufferKind::Global),
          /*tapGroupId=*/std::nullopt));
      bufSizes.erase(bufNameAttr);
    }

    // At this point, the only thing left should be the "test" buffer.
    assert(bufSizes.size() <= 1);
    for (auto [bufName, size] : bufSizes) {
      assert(bufName == "test");
      bufs.push_back(builder.getAttr<BufferDescAttr>(
          bufName,
          builder.getType<BufferType>(/*element=*/builder.getType<ValType>(),
                                      /*size=*/std::max<size_t>(bufSizes[bufName], 4),
                                      /*kind=*/BufferKind::Mutable),
          /*tapGroupId=*/std::nullopt));
    }

    setModuleAttr(getOperation(), builder.getAttr<BuffersAttr>(bufs));
  }
};

} // namespace

std::unique_ptr<OperationPass<ModuleOp>> createAnalyzeBuffersPass() {
  return std::make_unique<AnalyzeBuffersPass>();
}

} // namespace zirgen::Zhlt
