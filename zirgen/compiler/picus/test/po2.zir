// RUN: zirgen %s --emit=picus | FileCheck %s

// CHECK: (prime-number 2013265921)
// CHECK-NEXT: (begin-module Top)
// CHECK-DAG: (assert (= {{x[0-9]+}} 1))
// CHECK-DAG: (assert (= {{x[0-9]+}} 2))
// CHECK-DAG: (assert (= {{x[0-9]+}} 4))
// CHECK-DAG: (assert (= {{x[0-9]+}} 8))
// CHECK: (end-module)
// CHECK-NOT: (begin-module Po2)


// Inline this component, so that the subscript index resolves to a compile-time
// constant. This component isn't deterministic on its own, and there's not even
// a sensible way to translate it into Picus anyway! Note that this restriction
// applies in regular Zirgen code too â€” if Po2(x) were used in a constraint with
// an arbitrary runtime value x after inlining and unrolling, the compiler would
// emit an error.
#[picus_inline]
component Po2(n: Val) {
  arr := [1, 2, 4, 8];
  arr[n]
}

#[picus_analyze]
component Top() {
  public a := Reg(Po2(0));
  public b := Reg(Po2(1));
  public c := Reg(Po2(2));
  public d := Reg(Po2(3));
}
