// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/Tools/ParseUtilities.h"
#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
#include "llvm/ADT/TypeSwitch.h"

#include "zirgen/Dialect/ZHLT/IR/ZHLT.h"
#include "zirgen/Dialect/ZStruct/IR/ZStruct.h"
#include "zirgen/circuit/verify/wrap.h"

using zirgen::Val;
using zirgen::verify::CircuitBase;
using zirgen::verify::MixState;

namespace zirgen::verify {

using namespace zirgen::Zhlt;
using namespace zirgen::Zll;
using namespace mlir;

/// This provides a verifier interface for predicates to be able to
/// verify zirgen circuits.  It reads in an IR containing an evaluator
/// for the validity polynomial, and exposes it so predicates can
/// verifiy seals generated by zirgen circuits.
class CircuitInterfaceZirgen : public CircuitInterface {
public:
  CircuitInterfaceZirgen(OwningOpRef<mlir::ModuleOp> modArg)
      : ownedMod(std::move(modArg)), bufs(Zll::lookupModuleAttr<BuffersAttr>(mod())) {
    initialize();
  }
  const Zll::TapSet& get_taps() const override { return tapSet; }
  Val compute_poly(llvm::ArrayRef<Val> u,
                   llvm::ArrayRef<Val> out,
                   llvm::ArrayRef<Val> accumMix,
                   Val polyMix) const override;
  size_t out_size() const override { return bufs.getBuffer("global").getRegCount(); }
  size_t mix_size() const override { return bufs.getBuffer("mix").getRegCount(); }
  ProtocolInfo get_circuit_info() const override { return protocolInfo; }

private:
  void initialize();
  void add_taps();

  // ModuleOp's methods aren't very const safe, so operate on a copy instead of dereferencing
  // ownedMod.
  mlir::ModuleOp mod() const { return ModuleOp(*ownedMod); }

private:
  Zll::TapSet tapSet;

  OwningOpRef<mlir::ModuleOp> ownedMod;
  BuffersAttr bufs;
  FunctionOpInterface validityFunc;
  ProtocolInfo protocolInfo;
};

void CircuitInterfaceZirgen::initialize() {
  add_taps();

  for (auto& op : mod().getBody()->getOperations()) {
    if (auto funcOp = llvm::dyn_cast<FunctionOpInterface>(op)) {
      assert(!validityFunc && "Expecting only a single validity function");
      validityFunc = funcOp;
    }
  }

  assert(validityFunc && "Unable to find validity function");

  protocolInfo = lookupModuleAttr<Zll::ProtocolInfoAttr>(mod()).getValue();
}

void CircuitInterfaceZirgen::add_taps() {
  TapsAnalysis tapsAnalysis(mod());
  tapSet = tapsAnalysis.getTapSet();
}

namespace {

// Replaces a zll.get with its passed-in tap value
struct TapifyGetOp : public OpRewritePattern<Zll::GetOp> {
  TapifyGetOp(MLIRContext* ctx, llvm::ArrayRef<Val> tapVals)
      : OpRewritePattern(ctx), tapVals(tapVals) {}

  LogicalResult matchAndRewrite(Zll::GetOp op, PatternRewriter& rewriter) const final {
    auto tap = op->getAttrOfType<IntegerAttr>("tap");
    if (!tap) {
      return op->emitError("Missing tap");
    }
    rewriter.replaceOp(op, tapVals[tap.getUInt()].getValue());
    return success();
  }

private:
  llvm::ArrayRef<Val> tapVals;
};

// Replaces a zll.get_global of a buffer with a passed-in value
struct TapifyGetGlobalOp : public OpRewritePattern<Zll::GetGlobalOp> {
  TapifyGetGlobalOp(MLIRContext* ctx, mlir::Value oldBuf, llvm::ArrayRef<Val> vals)
      : OpRewritePattern(ctx), oldBuf(oldBuf), vals(vals) {}

  LogicalResult matchAndRewrite(Zll::GetGlobalOp op, PatternRewriter& rewriter) const final {
    if (op.getBuf() != oldBuf)
      return failure();
    rewriter.replaceOp(op, vals[op.getOffset()].getValue());
    return success();
  }

private:
  Value oldBuf;
  llvm::ArrayRef<Val> vals;
};

} // namespace

Val CircuitInterfaceZirgen::compute_poly(llvm::ArrayRef<Val> u,
                                         llvm::ArrayRef<Val> out,
                                         llvm::ArrayRef<Val> accumMix,
                                         Val polyMix) const {
  MLIRContext* ctx = mod().getContext();

  // This is called in an EDSL context, so we need to bind the buffers correctly.
  auto* edslModule = zirgen::Module::getCurModule();
  auto& builder = edslModule->getBuilder();

  FunctionOpInterface tapsWork;
  {
    IRRewriter::InsertionGuard guard(builder);
    builder.setInsertionPoint(validityFunc);
    // Keep our work in the loaded module so we can look up symbols.
    tapsWork = llvm::cast<FunctionOpInterface>(builder.clone(*validityFunc));
  }

  BuffersAttr bufs = lookupModuleAttr<Zll::BuffersAttr>(validityFunc);

  RewritePatternSet patterns(ctx);
  patterns.add<TapifyGetOp>(ctx, u);

  for (auto [argNum, arg] : llvm::enumerate(FunctionOpInterface(tapsWork).getArguments())) {
    auto name =
        FunctionOpInterface(tapsWork).getArgAttrOfType<StringAttr>(argNum, "zirgen.argName");
    if (!name)
      continue;

    auto buf = bufs.getBuffer(name);
    if (!buf || !buf.isGlobal())
      continue;

    if (buf.getName() == "global") {
      patterns.add<TapifyGetGlobalOp>(ctx, arg, out);
    } else if (buf.getName() == "mix") {
      patterns.add<TapifyGetGlobalOp>(ctx, arg, accumMix);
    } else {
      throw(std::runtime_error("Unknown buffer: " + buf.getName().str()));
    }
  }

  FrozenRewritePatternSet frozenPatterns(std::move(patterns));
  LogicalResult rewriteResult = applyPatternsAndFoldGreedily(tapsWork, frozenPatterns);
  assert(rewriteResult.succeeded() &&
         "Unable to apply patterns to generate wrapped zirgen verify function");

  // We should have replaced out all the get and get_globals, so we
  // can clone the resultant validity taps evaluator into the target EDSL
  // function.
  IRMapping mapping;

  // We substituted these values in, so map them to themselves
  for (auto buf : {u, out, accumMix}) {
    for (auto val : buf)
      mapping.map(val.getValue(), val.getValue());
  }

  // We want to separate out constraint ops (and_eqz, and_cond) into
  // multiplies.  So we need to separate the "Constraint" type into a
  // "mul" and a "tot" component.
  IRMapping mulMapping;
  IRMapping totMapping;

  Value zero = Val({0, 0, 0, 0}).getValue();
  Value one = Val({1, 0, 0, 0}).getValue();

  Value result;
  for (Operation& op : tapsWork.getFunctionBody().front()) {
    TypeSwitch<Operation*>(&op)
        .Case<Zll::TrueOp>([&](auto op) {
          totMapping.map(op, zero);
          mulMapping.map(op, one);
        })
        .Case<Zll::AndEqzOp>([&](auto op) {
          auto mulOp = builder.create<Zll::MulOp>(
              op.getLoc(), mulMapping.lookup(op.getIn()), mapping.lookup(op.getVal()));

          totMapping.map(
              op.getOut(),
              builder.create<Zll::AddOp>(op.getLoc(), mulOp, totMapping.lookup(op.getIn())));

          mulMapping.map(op.getOut(),
                         builder.create<Zll::MulOp>(
                             op.getLoc(), mulMapping.lookup(op.getIn()), polyMix.getValue()));
        })
        .Case<Zll::AndCondOp>([&](auto op) {
          auto mulOp1 = builder.create<Zll::MulOp>(
              op.getLoc(), mulMapping.lookup(op.getIn()), totMapping.lookup(op.getInner()));
          auto mulOp2 =
              builder.create<Zll::MulOp>(op.getLoc(), mulOp1, mapping.lookup(op.getCond()));

          totMapping.map(
              op.getOut(),
              builder.create<Zll::AddOp>(op.getLoc(), mulOp2, totMapping.lookup(op.getIn())));

          mulMapping.map(op.getOut(),
                         builder.create<Zll::MulOp>(op.getLoc(),
                                                    mulMapping.lookup(op.getIn()),
                                                    mulMapping.lookup(op.getInner())));
        })
        .Case<arith::ConstantOp, Zll::PolyOp, ZStruct::SubscriptOp, ZStruct::ArrayOp>([&](auto op) {
          Operation* cloned = builder.clone(*op, mapping);
          // Return type might be different, since we're likely to be operating on extension field
          // elements.
          if (auto inferOp = llvm::dyn_cast<InferTypeOpInterface>(cloned)) {
            reinferReturnType(inferOp);
          }
        })
        .Case<Zhlt::ReturnOp, func::ReturnOp>(
            [&](auto returnOp) { result = totMapping.lookup(returnOp.getOperands()[0]); })
        .Default([&](auto) {
          llvm::errs() << "Unexpected operation encountered when wrapping zirgen validity taps: "
                       << op << "\n";
          assert(false);
        });
  }
  tapsWork.erase();
  assert(result && "Missing terminator");
  return Val(result);
}

std::unique_ptr<CircuitInterface> getInterfaceZirgen(mlir::ModuleOp mod) {
  return std::make_unique<CircuitInterfaceZirgen>(mod);
}

std::unique_ptr<CircuitInterface> getInterfaceZirgen(mlir::MLIRContext* ctx,
                                                     mlir::StringRef filename) {
  ParserConfig config(ctx);
  OwningOpRef<ModuleOp> mod = parseSourceFile<ModuleOp>(filename, config);
  if (!mod)
    return nullptr;
  return std::make_unique<CircuitInterfaceZirgen>(std::move(mod));
}

} // namespace zirgen::verify
