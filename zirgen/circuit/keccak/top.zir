// RUN: true

import cycle_counter;
import keccak;
import poseidon2;

// Format on intermediate state:
//
// bits
// --------
// All 'bitwise' things are in 'little endian' order
// For init, and shutdown, bits are empty (zeros)
// For Keccak cycles, we have:
//   Keccak cycle 0: Output of ThetaP1, 5x64 bits
//   Keccak cycles 1, 3: Keccak state, low bits, 5x5x32
//   Keccak cycles 2, 4: Keccak state, high bits, 5x5x32
//   The same 2 cycle state is also used by 'Expand'
// For Poseidon2 rounds, the intermediate S-Box values
//
// kflat
// -------
// The 'flat' version of Keccak state is packed into 16 bits
// Order is 5x5x4, where the 4 16-bit parts of the 64 bit number
// are in 'little endian' order.
//
// pflat
// ------
// The 24 words of the Poseidon2 cross round state

// Make a 'top state' with the 3 elements are per above
component TopState(bits: Array<Val, 800>, kflat: Array<Val, 100>, pflat: Array<Val, 24>) {
  public bits := for i : 0..800 {
    Reg(bits[i])
  };
  // Log("Top State Top 16 bits = %x", Pack<16, 16>(for i : 0..16 { bits[i] })[0]);
  public kflat := for i : 0..100 {
    Reg(kflat[i])
  };
  public pflat := for i : 0..24 {
    Reg(pflat[i])
  };
}

// Convert state to 2 arrays of 800 bit each (split on word)
component FlattenKeccak(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  for kh : 0..2 {
    for y : 0..800 {
      kl := y & 31;
      ij := (y - kl) / 32;
      j := ij % 5;
      i := (ij - j) / 5;
      a[i + 0][j + 0][kh * 32 + kl]
    }
  }
}

// Convert back to 5x5x64
component ExpandKeccak(a: Array<Array<Val, 800>, 2>) {
  for i : 0..5 {
    for j : 0..5 {
      for k : 0..64 {
        kl := k & 31;
        kh := (k - kl) / 32;
        a[kh + 0][i*5*32 + j*32 + kl]
      }
    }
  }
}

component FlattenThetaB(b: Array<Array<Val, 64>, 5>) {
  for x : 0..800 {
    if (InRange(0, x, 5 * 64)) {
      k := x & 63;
      j := (x - k) / 64;
      b[j + 0][k]
    } else {
      0
    }
  }
}

component ExpandThetaB(b: Array<Val, 800>) {
  for j : 0..5 {
    for k : 0..64 {
      b[j * 64 + k]
    }
  }
}

// 5 cycles for 1 round of Keccak (ThetaP1, 2x Pi-Rho-ThetaP2, 2x Iota-Chi)
component KeccakRound0(s0: TopState, s1: TopState) {
  Log("KeccakRound0");
  a := ExpandKeccak([s0.bits, s1.bits]);
  b := ThetaP1(a);
  top := TopState(FlattenThetaB(b), s1.kflat, s1.pflat);
  for j : 0..5 {
    for k : 0..64 {
      AliasLayout!(top.bits[j*64 + k], b[j][k]);
    }
  };
  top
}

component KeccakRound12<IDX: Val>(sb: TopState, s0: TopState, s1: TopState, back1: TopState) {
  Log("KeccakRound12");
  a := ExpandKeccak([s0.bits, s1.bits]);
  b := ExpandThetaB(sb.bits);
  TopState(FlattenKeccak(Pi(Rho(ThetaP2(a, b))))[IDX], back1.kflat, back1.pflat)
}

component KeccakRound34<IDX: Val>(s0: TopState, s1: TopState, back1: TopState, round: Val) {
  Log("KeccakRound34", round);
  a := ExpandKeccak([s0.bits, s1.bits]);
  TopState(FlattenKeccak(Iota(Chi(a), round))[IDX], back1.kflat, back1.pflat)
}

component LoadPoseidon2(pf: Array<Val, 24>, kf: Array<Val, 100>, round: OneHot<7>) {
  last16 := round -> (
    for i : 0..16 { kf[i + 0] },
    for i : 0..16 { kf[i + 16] },
    for i : 0..16 { kf[i + 32] },
    for i : 0..16 { kf[i + 48] },
    for i : 0..16 { kf[i + 64] },
    for i : 0..16 { kf[i + 80] },
    [kf[96], kf[97], kf[98], kf[99], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  );
  for i : 0..24 { if (InRange(0, i, 16)) { last16[i] } else { pf[i] } }
}

component DoSponge(stage0: Array<Val, 24>) {
  stage0x := for v : MultiplyByMExt(stage0) { Reg(v) };
  stage1 := DoExtRoundByIdx(stage0x, 0);
  stage2 := DoExtRoundByIdx(stage1, 1);
  stage3 := DoExtRoundByIdx(stage2, 2);
  stage4 := DoExtRoundByIdx(stage3, 3);
  stage5 := DoIntRounds(stage4);
  stage6 := DoExtRoundByIdx(stage5, 4);
  stage7 := DoExtRoundByIdx(stage6, 5);
  stage8 := DoExtRoundByIdx(stage7, 6);
  stage9 := DoExtRoundByIdx(stage8, 7);
  stage9
}

component Poseidon2Cycle(back1: TopState, round: Val) {
  Log("Poseidon2Cycle", round);
  // Create initial Poseidon2 state
  roundOH := OneHot<7>(round);
  stateIn := LoadPoseidon2(back1.pflat, back1.kflat, roundOH);
  // TODO: actual code here
  stateOut := DoSponge(stateIn);
  bits := for x : 0..800 { 0 };
  topState := TopState(bits, back1.kflat, stateOut);
  /*
  for i : 0..8 {
    for j : 0..32 {
      AliasLayout!(steps[i].a[j], topState.bits[0 + i*32 + j]);
      AliasLayout!(steps[i].e[j], topState.bits[256 + i*32 + j]);
      AliasLayout!(steps[i].w[j], topState.bits[512 + i*32 + j]);
    }
  };
  */
  topState
}

#[picus_inline]
component ExtractBits2(a: Array<Array<Val, 32>, 4>, e: Array<Array<Val, 32>, 4>, i: Val) {
  [
    InRange(0, i, 4),
    InRange(4, i, 8),
    InRange(8, i, 12),
    InRange(12, i, 16),
    InRange(16, i, 25)
  ] -> (
    for j : 0..32 {0},
    a[3 - (i - 4)],
    for j : 0..32 {0},
    e[3 - (i - 12)],
    for j : 0..32 {0}
  )
}

extern GetPreimage(idx: Val): Val;
extern NextPreimage(): Val;

/*
- Init cycle (sets up)

- 1 Read cycle - Loads kflat, sets up SHA
- 7 Poseidon2 cycles (mixes kflat + zeros into state)
- 2 Expand cycles: Loads kflat into Keccak state
- 24 * 5 keccak cycles (mixes Keccak state)
- Write cycle - Takes keccak output -> kflat
- 7 Poseidon2 cycles (mixes kflat + zeros into state)
*/

component CycleTypeShutdown() { 0 }
component CycleTypeRead() { 1 }
component CycleTypeExpand() { 2 }
component CycleTypeWrite() { 3 }
component CycleTypeKeccakRound0() { 4 }
component CycleTypeKeccakRound1() { 5 }
component CycleTypeKeccakRound2() { 6 }
component CycleTypeKeccakRound3() { 7 }
component CycleTypeKeccakRound4() { 8 }
component CycleTypePoseidon2() { 9 }
component CycleTypeInit() { 10 }

component InitCycle() {
  Log("InitCycle");
  bits := for i : 0..800 { 0 };
  kflat := for i : 0..100 { 0 };
  pflat := for i : 0..24 { 0 };
  state := TopState(bits, kflat, pflat);
  state
}

component SFlatToBits(f: Array<Val, 16>) {
  expWords := [
    0, 0, 0, 0, 0, 0, 0, 0,
    f[6], f[7], f[4], f[5], f[2], f[3], f[0], f[1],
    0, 0, 0, 0, 0, 0, 0, 0,
    f[14], f[15], f[12], f[13], f[10], f[11], f[8], f[9],
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0];
  UnpackReg<800, 16>(expWords)
}

component ReadCycle(stateIn: TopState) {
  Log("ReadCycle");
  load := for i : 0..100 { NondetReg(GetPreimage(i)) };
  PicusInput!(load);
  bits := for i : 0..800 { 0 };
  stateOut := TopState(bits, load, stateIn.pflat);
  for i : 0..100 {
    AliasLayout!(stateOut.kflat[i], load[i]);
  };
  stateOut
}

component ExpandCycle(back1: TopState, subType: Val) {
  Log("ExpandCycle");
  bits := UnpackReg<800, 16>(
    if (subType) {
      for x : 0..50 {
        j := x & 1;
        i := (x - j) / 2 + 0;
        back1.kflat[4*i + 2 + j]
      }
    } else {
      for x : 0..50 {
        j := x & 1;
        i := (x - j) / 2 + 0;
        back1.kflat[4*i + j]
      }
    }
  );
  state := TopState(bits, back1.kflat, back1.pflat);
  for i : 0..800 {
    AliasLayout!(state.bits[i], bits[i]);
  };
  state
}

component WriteCycle(back1: TopState, back2: TopState) {
  Log("WriteCycle");
  kflat := for x : 0..100 {
    j := x & 3;
    i := (x - j) / 4 + 0;
    [Isz(j), Isz(j - 1), Isz(j - 2), Isz(j - 3)] -> (
      Pack<16,16>(for k : 0..16 { back2.bits[i * 32 + k] })[0],
      Pack<16,16>(for k : 0..16 { back2.bits[i * 32 + 16 + k] })[0],
      Pack<16,16>(for k : 0..16 { back1.bits[i * 32 + k] })[0],
      Pack<16,16>(for k : 0..16 { back1.bits[i * 32 + 16 + k] })[0]
    )
  };
  bits := for i : 0..800 { 0 };
  state := TopState(bits, kflat, back1.pflat);
  state
}

component DigestReg(values: Array<Val, 8>) {
  values := for v : values { Reg(v) };
}

component ShutdownCycle(stateIn: TopState) {
  Log("ShutdownCycle");
  global finalDigest := DigestReg(for i : 0..8 { stateIn.pflat[16 + i] });
  bits := for x : 0..800 { 0 };
  kflat := for x : 0..100 { 0 };
  TopState(bits, kflat, stateIn.pflat)
}

component ControlState(cycleType: Val, subType: Val, round: Val) {
  public cycleType := Reg(cycleType);
  public subType := Reg(subType);
  public round := Reg(round);
}

component KeccackNextRound(prev: ControlState) {
  isLast := IsZero(prev.round - 23);
  if (isLast) {
    ControlState(CycleTypeWrite(), 0, 0)
  } else {
    ControlState(CycleTypeKeccakRound0(), 0, prev.round + 1)
  }
}

component Poseidon2NextRound(prev: ControlState) {
  isLast := IsZero(prev.round - 6);
  isLastRead := Reg(isLast * (1 - prev.subType));
  isLastWrite := Reg(isLast * prev.subType);
  [1 - isLast, isLastRead, isLastWrite] -> (
    ControlState(CycleTypePoseidon2(), prev.subType, prev.round + 1),
    ControlState(CycleTypeExpand(), 0, 0),
    CheckNextPreimage(prev)
  )
}

component CheckNextPreimage(prev: ControlState) {
  more := NondetReg(NextPreimage());
  PicusInput!(more);
  AssertBit(more);
  if (more) {
    ControlState(CycleTypeRead(), 0, 0)
  } else {
    ControlState(CycleTypeShutdown(), 0, 0)
  }
}

component ComputeCurrentStep(prevMux: Array<Val, 11>, prev: ControlState) {
  PicusHintEq!(reduce prevMux init 0 with Add, 1);
  prevMux -> (
    ControlState(CycleTypeShutdown(), 0, 0),  // Shutdown -> Shutdown
    ControlState(CycleTypePoseidon2(), 0, 0),  // Read -> Poseidon2
    if (prev.subType) {
      ControlState(CycleTypeKeccakRound0(), 0, 0)  // Expand1 -> Round0
    } else {
      ControlState(CycleTypeExpand(), 1, 0)  // Expand0 -> Expand1
    },
    ControlState(CycleTypePoseidon2(), 1, 0),  // Write -> Poseidon2
    ControlState(CycleTypeKeccakRound1(), 0, prev.round),
    ControlState(CycleTypeKeccakRound2(), 0, prev.round),
    ControlState(CycleTypeKeccakRound3(), 0, prev.round),
    ControlState(CycleTypeKeccakRound4(), 0, prev.round),
    KeccackNextRound(prev),
    Poseidon2NextRound(prev),
    ControlState(CycleTypeRead(), 0, 0)  // Init -> Read
  )
}

// Annoyingly back directly on OneHot doesn't work
component WrapOneHot(oneHot: OneHot<11>) {
  for i : 0..11 { Reg(oneHot.bits[i]) }
}

#[picus_analyze]
component Top() {
  global finalDigest: DigestReg;

  cycle := CycleCounter();
  cycleMux : WrapOneHot;
  controlState : ControlState;
  controlState := if (cycle.is_first_cycle) {
    controlState@1.cycleType = CycleTypeShutdown();
    ControlState(CycleTypeInit(), 0, 0)
  } else {
    ComputeCurrentStep(cycleMux@1, controlState@1)
  };
  oneHot := OneHot<11>(controlState.cycleType);
  cycleMux := WrapOneHot(oneHot);
  for i : 0..11 {
    AliasLayout!(oneHot[i], cycleMux[i]);
  };
  curState: TopState;
  curState := cycleMux -> (
    ShutdownCycle(curState@1),
    ReadCycle(curState@1),
    ExpandCycle(curState@1, controlState.subType),
    WriteCycle(curState@1, curState@2),
    KeccakRound0(curState@2, curState@1),
    KeccakRound12<0>(curState@1, curState@3, curState@2, curState@1),
    KeccakRound12<1>(curState@2, curState@4, curState@3, curState@1),
    KeccakRound34<0>(curState@2, curState@1, curState@1, controlState.round),
    KeccakRound34<1>(curState@3, curState@2, curState@1, controlState.round),
    Poseidon2Cycle(curState@1, controlState.round),
    InitCycle()
  );
}
